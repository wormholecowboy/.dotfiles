#!/bin/zsh

# Git Worktree Manager (gwm)
# Interactive worktree management using fzf

# Main loop
while true; do
  # Main menu
  action=$(printf "Add worktree\nDelete worktree\nRename worktree" | fzf --prompt="Select action: ")

  [[ -z "$action" ]] && exit 0

  if [[ "$action" == "Add worktree" ]]; then
  # Add flow
  branch_type=$(printf "existing\nnew" | fzf --prompt="Branch type: ")
  [[ -z "$branch_type" ]] && exit 0

  if [[ "$branch_type" == "existing" ]]; then
    # List all branches (local and remote)
    branch=$(git branch -a | sed 's/^[ *+]*//' | sed 's/remotes\///' | grep -v 'HEAD ->' | sort -u | fzf --prompt="Select branch: ")
    [[ -z "$branch" ]] && exit 0

    # Extract branch name for worktree directory
    # Check if branch starts with a remote name (e.g., origin/feature/foo)
    remote_prefix="${branch%%/*}"
    if git remote | grep -qx "$remote_prefix" 2>/dev/null; then
      # Remote branch - strip only the remote name, keep the rest (e.g., feature/foo)
      worktree_name="${branch#*/}"
    else
      # Local branch - use last component
      worktree_name=$(basename "$branch")
    fi

    # Check if worktree directory already exists
    if [[ -e "$worktree_name" ]]; then
      echo "Error: Directory '$worktree_name' already exists"
      exit 1
    fi

    # Check if this is a local branch by verifying refs/heads
    if git show-ref --verify --quiet "refs/heads/$branch"; then
      # Local branch - use directly
      git worktree add "$worktree_name" "$branch"
    else
      # Remote branch - create local tracking branch
      local_branch="$worktree_name"

      # Check if local branch with this name already exists
      if git show-ref --verify --quiet "refs/heads/$local_branch"; then
        echo "Local branch '$local_branch' already exists, using existing branch"
        git worktree add "$worktree_name" "$local_branch"
      else
        echo "Creating local branch '$local_branch' tracking '$branch'"
        git worktree add --track -b "$local_branch" "$worktree_name" "$branch"
      fi
    fi
  else
    # Create new branch
    echo -n "Enter new branch name: "
    read branch_name

    [[ -z "$branch_name" ]] && echo "No branch name provided" && exit 1

    # Pick base branch
    base_branch=$(git branch -a | sed 's/^[ *+]*//' | sed 's/remotes\///' | grep -v 'HEAD ->' | sort -u | fzf --prompt="Select base branch: ")
    [[ -z "$base_branch" ]] && exit 0

    # Check if directory already exists
    if [[ -e "$branch_name" ]]; then
      echo "Error: Directory '$branch_name' already exists"
      exit 1
    fi

    # Create worktree with new branch
    git worktree add -b "$branch_name" "$branch_name" "$base_branch"
  fi
  exit 0
  fi

  if [[ "$action" == "Delete worktree" ]]; then
  # Delete flow
  # List worktrees
  worktree=$(git worktree list | fzf --prompt="Select worktree to delete: " | awk '{print $1}')
  [[ -z "$worktree" ]] && exit 0

  # Extract worktree name
  worktree_name=$(basename "$worktree")

  # Get the branch that was associated with this worktree (before removing)
  branch_name=$(git worktree list --porcelain | awk -v wt="$worktree" '
    $1 == "worktree" && $2 == wt {found=1; next}
    found && $1 == "branch" {sub(/^refs\/heads\//, "", $2); print $2; exit}
  ')

  # Check for uncommitted changes
  if [[ -n $(git -C "$worktree" status --porcelain 2>/dev/null) ]]; then
    echo "⚠️  Warning: Worktree '$worktree_name' has uncommitted changes!"
    force=$(printf "Cancel\nForce delete" | fzf --prompt="Uncommitted changes detected: ")

    [[ "$force" != "Force delete" ]] && echo "Cancelled" && exit 0

    git worktree remove --force "$worktree"
  else
    git worktree remove "$worktree"
  fi

  echo "Worktree removed successfully"

  # Ask about deleting the associated branch
  if [[ -n "$branch_name" ]] && git show-ref --verify --quiet "refs/heads/$branch_name"; then
    confirm=$(printf "No\nYes" | fzf --prompt="Delete branch '$branch_name' (was on this worktree)? ")

    if [[ "$confirm" == "Yes" ]]; then
      if git branch -d "$branch_name" 2>/dev/null; then
        echo "Branch '$branch_name' deleted"
      else
        echo "Branch has unmerged changes."
        force_branch=$(printf "Cancel\nForce delete" | fzf --prompt="Force delete branch? ")
        if [[ "$force_branch" == "Force delete" ]]; then
          git branch -D "$branch_name"
          echo "Branch '$branch_name' force deleted"
        fi
      fi
    fi
  fi
  fi

  if [[ "$action" == "Rename worktree" ]]; then
  # Rename flow
  # List worktrees (excluding main repo)
  worktree=$(git worktree list | tail -n +2 | fzf --prompt="Select worktree to rename: " | awk '{print $1}')
  [[ -z "$worktree" ]] && exit 0

  # Get the current worktree directory name
  current_name=$(basename "$worktree")

  # Get the branch associated with this worktree
  branch_name=$(git worktree list --porcelain | awk -v wt="$worktree" '
    $1 == "worktree" && $2 == wt {found=1; next}
    found && $1 == "branch" {sub(/^refs\/heads\//, "", $2); print $2; exit}
  ')

  if [[ -z "$branch_name" ]]; then
    echo "Error: Could not determine branch for worktree"
    exit 1
  fi

  # Prompt for new name
  echo -n "Enter new name for worktree/branch '$current_name': "
  read new_name

  [[ -z "$new_name" ]] && echo "No name provided" && exit 1

  # Check if new directory already exists
  parent_dir=$(dirname "$worktree")
  new_path="$parent_dir/$new_name"

  if [[ -e "$new_path" ]]; then
    echo "Error: Directory '$new_path' already exists"
    exit 1
  fi

  # Check if new branch name already exists
  if git show-ref --verify --quiet "refs/heads/$new_name"; then
    echo "Error: Branch '$new_name' already exists"
    exit 1
  fi

  # Rename the branch first
  git branch -m "$branch_name" "$new_name"
  echo "Branch renamed: $branch_name → $new_name"

  # Move the worktree directory (git tracks this properly)
  git worktree move "$worktree" "$new_path"
  echo "Worktree moved: $current_name → $new_name"

  echo "✓ Worktree and branch successfully renamed to '$new_name'"
  exit 0
  fi
done
